	/*
	 *
	 * General Functions,
	 * Input - according to requirements; Output - non-geometric primitives
	 *
	 */

	/**
	 * Prints to console
	 * @param {string} content - Message to be printed on the console
	 * @returns {null}
	 */
	print = function(content){
		// try to find vidamo web app, if found print in vidamo console

		this.content = content;

		try{
			var logString = "<div style='color: green;'>" + this.content + '</div>';
			document.getElementById('log').innerHTML += logString;
		}catch(err){
			console.log('warnning: vidamo web app not connected.');
		}
	};

	/**
	 * Converts RGB values into Hex color code
	 * @param {int} red - Value between 0-255 for red color
	 * @param {int} green - Value between 0-255 for green color
	 * @param {int} blue - Value between 0-255 for blue color
	 * @returns {string} - HexValue
	 */
	rgbToHex = function(red, green, blue){
		
		return '0x'+toHex(red)+toHex(green)+toHex(blue);
			
		function toHex(n) {
			 n = parseInt(n,10);
			 if (isNaN(n)) return "00";
			 n = Math.max(0,Math.min(n,255));
			 return "0123456789ABCDEF".charAt((n-n%16)/16)
				  + "0123456789ABCDEF".charAt(n%16);
		}
	};
	
	/**
	 * Converts degrees into radians
	 * @param {float} degree - Degrees to be converted
	 * @returns {float} 
	 */
	convertDegreesToRadians = function( degrees ){
		return 0.01745*degrees;
	};

	/**
	 * Converts radians into degrees
	 * @param {float} radians - Radians to be converted
	 * @returns {float} 
	 */
	convertRadiansToDegrees = function( radians ){
		return 57.29*radians;
	};

	/**
	 * Returns absolute (positive) value of a number
	 * @param {float} number  
	 * @returns {float} Positive value
	 */
	getAbsoluteValue = function( number ){
		return Math.abs( number );
	};

	/**
	 * Returns value of a number upto significant digits
	 * @param {float} number  - Number
	 * @param {int} number  - Number of significant digits needed
	 * @returns {float} 
	 */
	getSignificantDigits = function( number, digits ){
		return number.toFixed(digits);
	};

	/**
	 * Computes dot product of two matrices
	 * @param {array} mat1  - Matrix 1
	 * @param {array} mat2  - Matrix 2
	 * @returns {float} 
	 */
	getDotProduct = function( mat1, mat2 ){
		return verb.core.Vec.dot(mat1, mat2);
	};

	/**
	 * Computes cross product of two matrices
	 * @param {array} mat1  - Matrix 1
	 * @param {array} mat2  - Matrix 2
	 * @returns {array} 
	 */
	getCrossProduct = function( mat1, mat2 ){
		return verb.core.Vec.cross(mat1, mat2);
	};

	/**
	 * Computes angle between two vectors
	 * @param {array} vector1  - Vector 1 in [x, y, z] format
	 * @param {array} vector2  - Vector 2 in [x, y, z] format
	 * @returns {float} radians
	 */
	getAngleBetweenVectors = function( vector1, vector2 ){
		var dotP = VIDAMO.getDotProduct( vector1,  vector2 );
		var cos_t = dotP / (VIDAMO.getLengthOfVector( vector1 ) * VIDAMO.getLengthOfVector( vector2 ) );
		return Math.cosh(cos_t);
	};

	/**
	 * Computes length of the vector
	 * @param {array} vector  - Vector in [x, y, z] format
	 * @returns {float} length
	 */
	getLengthOfVector = function ( vector ){
		return Math.sqrt( vector[0]*vector[0] + vector[1]*vector[1] + vector[2]*vector[2] );
	};

	/**
	 * Computes unit vector
	 * @param {array} vector  - Vector in [x, y, z] format
	 * @returns {array} Unit Vector
	 */
	getUnitVector = function( vector ){
		return verb.core.Vec.normalized( vector )
	}

	/**
	 * Multiples a vector with a factor
	 * @param {float / int } factor - Value to be multiplied
	 * @param {array} vector  - Vector in [x, y, z] format 
	 * @returns {array} 
	 */
	multiplyArray = function( factor, array ){
		return [ factor*array[0], factor*array[1], factor*array[2] ] ;
	}
	

	/*
	 *
	 * List Operations
	 *
	 */

	/**
	 * Returns a number sequence in the form of an array
	 * @param {float or int} start  - Starting value of the sequence
	 * @param {float or int} end  - Ending value of the sequence (not included in the sequence)
	 * @param {float or int} stepSize  - Increment or Decrement value to get to the 'end' value from the 'start' value
	 * @returns {array} 
	 */
	makeSequence = function(start, end, stepSize){

		var arr = [];
		if( start == end ){
			arr.push(start);
		}
		else if(start > end && stepSize < 0){
			for(var i = start; i > end; i = i + stepSize)
				arr.push(i);
		} 
		else{
			for(var i = start; i < end; i = i + stepSize)
				arr.push(i);
		}

		return arr;
	};

	/**
	 * Adds an element to a list
	 * @param {array} list  - List to which an element needs to be pushed
	 * @param {array element} object - Element to be pushed into the list
	 * @returns null
	 */
	addToList = function( list, object ){
		list.push( object );
	};

	/**
	 * Appends to the list
	 * @param {array} list  - List to which an element needs to be appeneded
	 * @param {array} object - Elements to be pushed into the list
	 * @returns null
	 */
	appendToList = function( list, object ){
		
		// this method would require return value - not in sync with addToList
		//return list.concat(object);		
		if( object.constructor.name == "Array"){
			object.map( function(t){
				list.push(t);
			});
		}

	};


	/**
	 * Finds the index of the first occurence of an array element. 
	 * @param {array} list  - List in which an element needs to be searched
	 * @param {array element} object - Element to be searched for
	 * @returns {int} Returns -1 if the element doesn't exist in array. 
	 */
	indexOfObject = function( list, object ){
		return list.indexOf( object );
	};

	/**
	 * Removes an array element from a list by it's index number
	 * @param {array} list  - List in which an element needs to be removed
	 * @param {int} index - Index to be removed
	 * @returns {null} 
	 */
	removeIndexFromList = function( list, index ){
		list.splice(index, 1);
	};

	/**
	 * Gets the maximum value in a numeric array
	 * @param {array} valueList - List from which maximum value is required
	 * @returns {float / int} 
	 */
	getMaxValue = function( valueList ){
		var maxValue = valueList[0];
		for(var i=0; i<valueList.length; i++)
			maxValue = Math.max(maxValue, valueList[i]);
		return maxValue;
	};

	/**
	 * Gets the minimum value in a numeric array
	 * @param {array} valueList - List from which minimum value is required
	 * @returns {float / int} 
	 */
	getMinValue = function( valueList ){
		var minValue = valueList[0];
		for(var i=0; i<valueList.length; i++)
			minValue = Math.min(minValue, valueList[i]);
		return minValue;
	};

	/**
	 * Gets the sum of a numeric array
	 * @param {array} valueList - List which is to be summed
	 * @returns {float / int} 
	 */
	sumList = function( valueList ){
		var sum = 0;
		for(var i=0; i<valueList.length; i++)
			sum += valueList[i];
		return sum;
	};

	/**
	 * Gets the avaerage of a numeric array
	 * @param {array} valueList - List which is to be averaged
	 * @returns {float / int} 
	 */
	averageList = function( valueList ){
		return VIDAMO.sumList( valueList )/ valueList.length;
	};

	/**
	 * Returns the span of the list - the difference between the maximum and the minimum value in the list
	 * @param {array} valueList - List which is to be analyzed
	 * @returns {float / int} 
	 */
	rangeOfList = function( valueList ){
		return VIDAMO.getMaxValue( valueList ) - VIDAMO.getMinValue( valueList );
	};

	/**
	 * Returns the length of the list 
	 * @param {array} valueList - List which is to be analyzed
	 * @returns {int} 
	 */
	getListLength = function( valueList ){
		return valueList.length
	};


	/*
	 *
	 *	Geometry Analysis Functions
	 *
	 */

	/**
	 * Returns the centre of a NURBS Curve, NURBS Surface or geometry for which centre is defined
	 * @param {array} mObj - Mobius object
	 * @returns {array} Point - [x, y, z]
	 */
	getCentre = function(mObj){
		//calculate centre based on what kind of object
		var geometry = mObj.getGeometry();  

		if(geometry.center != undefined)
			return geometry.center();
		else if(geometry instanceof verb.geom.NurbsCurve)
			return geometry.point(0.5);
		else if(geometry instanceof verb.geom.NurbsSurface)
			return geometry.point(0.5, 0.5);
		else
			return "Invalid Input"
	};

	/**
	 * Returns the distance between two points or vertices
	 * @param {point / vertex} point - [x, y, z] or vertex object
	 * @returns {float} Distance 
	 */
	distanceBetweenTwoPoints = function( point1, point2){

		if( point1.getGeometry != undefined )
			point1 = point1.getGeometry();
		if( point2.getGeometry != undefined )
			point2 = point2.getGeometry();
				 
		var deltaX, deltaY, deltaZ;

		deltaX = point1[0] - point2[0];
		deltaY = point1[1] - point2[1];
		deltaZ = point1[2] - point2[2];

		var distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ);
		return distance;
	};


	/**
	 * Returns the mid-point between two points
	 * @param {point / vertex} point - [x, y , z] or Vertex
	 * @returns {float} Distance 
	 */
	getMidPoint = function( point1, point2){

		if( point1.getGeometry != undefined )
			point1 = point1.getGeometry();
		if( point2.getGeometry != undefined )
			point2 = point2.getGeometry();

		return [ (point1[0] + point2[0])/2, (point1[1] + point2[1])/2, (point1[2] + point2[2])/2 ];
	};	



	/**
	 * Returns the length of an object
	 * @param {MobiusObject} mObj -  
	 * @returns {float} Length 
	 */
	getLength = function( mObj ){

		if( mObj.getGeometry().length != undefined){
			return mObj.getGeometry().length();
		}
	};


	/*
	 *
	 * Verbs Functions
	 * Input - according to requirements, Output - mobiusobject with NURBS Geometry
	 *
	 */
	
	//
	//	Curve Functions
	//
	//
	
	/**
	 * Returns a Mobius Curve object
	 * @param {array} startPoint - Starting point of the line in [x,y,z] format or Vertex Object
	 * @param {array} endPoint - Ending point of the line in [x,y,z] format	or Vertex Object
	 * @returns {MobiusObject}  - NURBS Curve
	 */
	makeLine = function(startPoint, endPoint){
		// input variations
		// start, end could be a vector3 - has to be converted into an array

		if( startPoint.getGeometry != undefined )
			startPoint = startPoint.getGeometry();
		if( endPoint.getGeometry != undefined )
			endPoint = endPoint.getGeometry();
	
		return new mObj_geom_Curve( new verb.geom.Line(startPoint, endPoint) );
		
		// topology : curve class
	};

	/**
	 * Returns a mobiusobject containing a NURBS Curve
	 * @param {array} centerPoint - Centre point of the Arc in [x,y,z] format or Vertex Object
	 * @param {array} xaxis - Direction of X-Axis of the Arc in [x,y,z] format 
	 * @param {array} yaxis - Direction of Y-Axis of the Arc in [x,y,z] format 
	 * @param {array} radius - Radius of the Arc
	 * @param {float} minAngle - Minimum Angle in Radians
	 * @param {float} maxAngle - Maximum Angle in Radians
	 * @returns {mobiusobject}  - NURBS Curve
	 */
	makeArc = function(centerPoint, xaxis, yaxis, radius, minAngle, maxAngle){
		// input variations
		// center, axis and yaxis could be vector3
		if( centerPoint.getGeometry != undefined )
			centerPoint = centerPoint.getGeometry();

		return new mObj_geom_Curve( new verb.geom.Arc(centerPoint,xaxis,yaxis,radius,minAngle,maxAngle) ) ;

	};

	/**
	 * Returns a mobiusobject containing a NURBS Curve
	 * @param {array} points - Array of Control Points for the Bezier Curve ( [[x1, y1, z1], [x2, y2, z2], [x3, y3, z3], [x4, y4, z4], ...] or Vertices )
	 * @param {array} weights - Weights
	 * @returns {mobiusobject}  - NURBS Curve
	 */
	makeBezierCurve = function(points, weights){

		var points = points.map( function(p){ 
								
								if(p.getGeometry != undefined) 
									return p.getGeometry(); 
								else 
									return p; } )

		return new mObj_geom_Curve( new verb.geom.BezierCurve(points, weights) ) 
	};

	/**
	 * Returns a mobiusobject containing a NURBS Curve
	 * @param {array} centerPoint - Centre point of the Circle in [x,y,z] format or Vertex Object
	 * @param {array} xaxis - Direction of X-Axis of the Circle in [x,y,z] format 
	 * @param {array} yaxis - Direction of Y-Axis of the Circle in [x,y,z] format 
	 * @param {array} radius - Radius of the Arc
	 * @returns {mobiusobject}  - NURBS Curve
	 */
	makeCircleBoundary = function(centerPoint,xaxis,yaxis,radius){

		if( centerPoint.getGeometry != undefined )
			centerPoint = centerPoint.getGeometry();

		return new mObj_geom_Curve( new verb.geom.Circle(centerPoint,xaxis,yaxis,radius) ) 
	};

	/**
	 * Returns a mobiusobject containing a NURBS Curve
	 * @param {array} centerPoint - Centre point of the Ellipse in [x,y,z] formats or Vertex Object
	 * @param {array} xaxis - Direction of X-Axis of the Ellipse in [x,y,z] format; Length of this vector determines length of x-Axis of ellipse;
	 * @param {array} yaxis - Direction of Y-Axis of the Ellipse in [x,y,z] format; Length of this vector determines length of y-Axis of ellipse;
	 * @returns {mobiusobject}  - NURBS Curve
	 */
	makeEllipse = function ( centerPoint ,xaxis,yaxis ){

		if( centerPoint.getGeometry != undefined )
			centerPoint = centerPoint.getGeometry();

		return new mObj_geom_Curve( new verb.geom.Ellipse( centerPoint,xaxis,yaxis ) ) 
		
	};

	/**
	 * Returns a mobiusobject containing a NURBS Curve
	 * @param {array} centerPoint - Centre point of the EllipseArc in [x,y,z] formats or Vertex Object
	 * @param {array} xaxis - Direction of X-Axis of the EllipseArc in [x,y,z] format; Length of this vector determines length of x-Axis of ellipse;
	 * @param {array} yaxis - Direction of Y-Axis of the EllipseArc in [x,y,z] format; Length of this vector determines length of y-Axis of ellipse;
	 * @param {float} minAngle - Minimum Angle in Radians
	 * @param {float} maxAngle - Maximum Angle in Radians
	 * @returns {mobiusobject}  - NURBS Curve
	 */
	makeEllipseArc = function ( centerPoint,xaxis,yaxis,minAngle,maxAngle ){

		if( centerPoint.getGeometry != undefined )
			centerPoint = centerPoint.getGeometry();


		return new mObj_geom_Curve( new verb.geom.EllipseArc( centerPoint,xaxis,yaxis,minAngle,maxAngle ) ) 
		// topology : curve class
	};

	/**
	 * Returns a mobiusobject containing a NURBS Curve
	 * @param {array} points - Array of points / vertices through which the curve passes ( [[x1, y1, z1], [x2, y2, z2], [x3, y3, z3], [x4, y4, z4], ...] )
	 * @param {int} degree - Degree of the Curve
	 * @returns {mobiusobject}  - NURBS Curve
	 */
	makeCurveByPoints = function( points, degree ){

		points = points.map( function(p){ 
								
								if(p.getGeometry != undefined) 
									return p.getGeometry(); 
								else 
									return p; } )

		return new mObj_geom_Curve( new verb.geom.NurbsCurve.byPoints( points, degree ) ) ;
	};

	/**
	 * Returns a mobiusobject containing a NURBS Curve
	 * @param {int} degree - Degree of the Curve
	 * @param {array} knots - Knots
	 * @param {array} controlPoints - Array of points / vertices through which the curve passes ( [[x1, y1, z1], [x2, y2, z2], [x3, y3, z3], [x4, y4, z4], ...] )
	 * @param {array} weights - Weights
	 * @returns {mobiusobject}  - NURBS Curve
	 */
	makeCurveByKnotsControlPointsWeights = function ( degree,knots,controlPoints,weights ){

		controlPoints = controlPoints.map( function(p){ 
								
								if(p.getGeometry != undefined) 
									return p.getGeometry(); 
								else 
									return p; } )

		return new mObj_geom_Curve( new verb.geom.NurbsCurve.byKnotsControlPointsWeights( degree,knots,controlPoints,weights ) ) ;
		// topology : curve class
	};

	/**
	 * Returns a mobiusobject containing a NURBS Surface
	 * @param {int} degreeU - DegreeU of the Surface
	 * @param {int} degreeV - DegreeV of the Surface
	 * @param {array} knotsU - Knots in U Direction
	 * @param {array} knotsV - Knots in V Direction
	 * @param {array} controlPoints - Array of points / vertices through which the curve passes ( [[x1, y1, z1], [x2, y2, z2], [x3, y3, z3], [x4, y4, z4], ...] )
	 * @param {array} weights - Weights
	 * @returns {mobiusobject}  - NURBS Surface
	 */
	makeSurfaceByKnotsControlPointsWeights = function ( degreeU,degreeV,knotsU,knotsV,controlPoints,weights ){
		
		controlPoints = controlPoints.map( function(p){ 
								
								if(p.getGeometry != undefined) 
									return p.getGeometry(); 
								else 
									return p; } )

		return new mObj_geom_Surface( new verb.geom.NurbsSurface.byKnotsControlPointsWeights( degreeU,degreeV,knotsU,knotsV,controlPoints,weights ) ) ;
		// topology : single surface - cant be exploded
		// brep : face -> surface (1); edges -> boundaries (4) ; vertex -> corner points (4)
	};

	/**
	 * Returns a mobiusobject containing a NURBS Surface
	 * @param {array} point - Corner points in [x,y,z] format / Vertex Objects
	 * @returns {mobiusobject}  - NURBS Surface
	 */
	makeSurfaceByCorners = function ( point0, point1, point2, point3 ){

		if( point0.getGeometry != undefined )
			point0 = point0.getGeometry();
		if( point1.getGeometry != undefined )
			point1 = point1.getGeometry();
		if( point2.getGeometry != undefined )
			point2 = point2.getGeometry();
		if( point3.getGeometry != undefined )
			point3 = point3.getGeometry();

		return new mObj_geom_Surface( new verb.geom.NurbsSurface.byCorners ( point0,point1,point2,point3 ) ) ;
		// topology : single surface - cant be exploded
		// brep : face -> surface (1); edges -> boundaries (4) ; vertex -> corner points (4)
	};

	/**
	 * Returns a mobiusobject containing a NURBS Surface
	 * @param {mobiusobject} mObj - mobiusobject with NURBS Curve Geometry
	 * @param {array} centerPoint - CentrePoint in [x,y,z] format or Vertex Object
	 * @param {array} axis - Axis of revolution in [x,y,z] format	 
	 * @param {float} angle - Angle of revolution in radians
	 * @returns {mobiusobject}  - NURBS Surface
	 */
	makeSurfaceByRevolution = function ( mobiusGeometry, centerPoint, axis, angle ){

		if( centerPoint.getGeometry != undefined )
			centerPoint = centerPoint.getGeometry();

		var profile = mobiusGeometry.getGeometry();
		return new mObj_geom_Surface( new verb.geom.RevolvedSurface( profile, centerPoint, axis, angle ) ) ;
	
		// topology : single surface - cant be exploded
		// brep : face -> surface (1); edges -> boundaries (4) ; vertex -> corner points (4) - if incomplete circle, else one boundary, one vertex
	};

	/**
	 * Returns a mobiusobject containing a NURBS Surface
	 * @param {mobiusobject} mObj - mobiusobject with NURBS Curve Geometry
	 * @param {mobiusobject} mObj - mobiusobject with NURBS Curve Geometry
	 * @returns {mobiusobject}  - NURBS Surface
	 */
	makeSurfaceBySweep = function ( mObjProfile, mObjRail){
		var profile = mObjProfile.getGeometry();
		var rail = mObjRail.getGeometry();
		return new mObj_geom_Surface( new verb.geom.SweptSurface ( profile, rail ) ) ;
		// topology : single surface - cant be exploded
		// brep : face -> surface (1); edges -> boundaries (4) ; vertex -> corner points (4)
	};

	/**
	 * Returns a mobiusobject containing a NURBS Surface
	 * @param {array} listOfCurves - Array of mobiusobject with NURBS Curve Geometry
	 * @param {int} degree - Degree of the Surface
	 * @returns {mobiusobject}  - NURBS Surface
	 */
	makeSurfaceByLoft = function(listOfCurves, degree){
		var deg = degree || 3;
		var curves = []; l = listOfCurves;
		for(var c=0; c<listOfCurves.length; c++)
			curves.push(listOfCurves[c].getGeometry()); 
		return new mObj_geom_Surface( new verb.geom.NurbsSurface.byLoftingCurves( curves, deg ) ) ;
		
		// topology : single surface - cant be exploded
		// brep : face -> surface (1); edges -> boundaries (4) ; vertex -> corner points (4)
	};

	/**
	 * Returns a mobiusobject containing a NURBS Surface
	 * @param {mobiusobject} mObjProfile - Array of mobiusobject with NURBS Curve Geometry
	 * @param {array} direction - Direction of Sweep in [x,y,z] format	 
	 * @returns {mobiusobject}  - NURBS Surface
	 */
	makeSurfaceByExtrusion = function ( mObjProfile, direction){
		var profile = mObjProfile.getGeometry();
		return new mObj_geom_Surface(  new verb.geom.ExtrudedSurface( profile, direction ) ) ;
		
		// topology : single surface - cant be exploded
		// brep : face -> surface (1); edges -> boundaries (4) ; vertex -> corner points (4)
	};


	/*
	 * Returns a mobiusobject containing a NURBS Surface
	 * @param {mobiusobject} mObjProfile - Array of mobiusobject with NURBS Curve Geometry
	 * @param {array} direction - Direction of Sweep in [x,y,z] format	 
	 * @returns {mobiusobject}  - NURBS Surface
	 
	makeCircle = function( centrePoint, radius ){

		if( centerPoint.getGeometry != undefined )
			centerPoint = centerPoint.getGeometry();

		var radialLine = VIDAMO.makeLine( centrePoint, [centrePoint[0]+radius, centrePoint[1], centrePoint[2]] );
		return VIDAMO.makeSurfaceByRevolution( radialLine, centrePoint, [0,1,0] );
	};
	*/



	
	//
	// Surface Functions - Applications
	//
	//
	
	
	/**
	 * Returns a mobiusobject containing a NURBS Surface
	 * @param {array} centrePoint - CentrePoint in [x,y,z] format or Vertex Object	 
	 * @param {float} radius - Radius of the Sphere 	 
	 * @returns {mobiusobject}  - NURBS Surface
	 */
	makeSphere = function(centrePoint, radius){

		if( centerPoint.getGeometry != undefined )
			centerPoint = centerPoint.getGeometry();
					
		return new mObj_geom_Surface(  new verb.geom.SphericalSurface(centrePoint, radius) ) ;
		// topology : single surface - cant be exploded
		// brep : face -> surface (1); edges -> arc (1) ; vertex -> corner point (1)
		// revolution surface - will contain the same details
	};

	/**
	 * Returns a mobiusobject containing a NURBS Surface
	 * @param {array} axis - Axis Direction of the cone in [x,y,z] format
	 * @param {array} xaxis - Direction of x-axis of cone in [x,y,z] format
	 * @param {float} base - Radius of cone base
	 * @param {float} height - Height of the cone
	 * @param {float} radius - Radius of cone
	 * @returns {mobiusobject}  - NURBS Surface
	 */
	makeCone = function( axis,xaxis,base,height,radius ){
		return new mObj_geom_Surface( new verb.geom.ConicalSurface( axis,xaxis,base,height,radius ) ) ;
	};

	/**
	 * Returns a mobiusobject containing a NURBS Surface
	 * @param {array} axis - Axis Direction of the cylinder in [x,y,z] format
	 * @param {array} xaxis - Direction of x-axis of cylinder in [x,y,z] format
	 * @param {float} base - Radius of cylinder base
	 * @param {float} height - Height of the cylinder
	 * @param {float} radius - Radius of cylinder
	 * @returns {mobiusobject}  - NURBS Surface
	 */
	makeCylinder = function ( axis, xaxis, base, height, radius, capped ){
		if(capped){
			//return a solid			
		}
		else
			return new mObj_geom_Surface( new verb.geom.CylindricalSurface( axis,xaxis,base,height,radius ))  ;
	};
	
	//
	//	Solid Functions
	//
	//
	
	/**
	 * Returns a mobiusobject containing a NURBS Surface
	 * @param {array} axis - Axis Direction of the cylinder in [x,y,z] format
	 * @param {array} xaxis - Direction of x-axis of cylinder in [x,y,z] format
	 * @returns {mobiusobject}  - NURBS Surface
	 
	makeTube = function( centrePoint, innerRadius, outerRadius, height){
		
	};	*/


	/**
	 * Returns a mobiusobject containing a solid (array of surfaces)
	 * @param {mobius surface} surface - Mobius Surface Object to be extruded
	 * @param {array} extrusion vector - Direction of extrusion in [x, y, z] format
	 * @returns {mobiusobject}  - Solid
	 */
	makeSolidByExtrusion = function( surface, extrusionVector ){
		var bottomSurface = surface;
		var topSurface = VIDAMO.makeCopy( bottomSurface, undefined, undefined, undefined);
		VIDAMO.shiftObject(topSurface, extrusionVector[0], extrusionVector[1], extrusionVector[2]);

		var solid = [ bottomSurface, topSurface ];
		// join boundary points of the two surfaces
		var edges = bottomSurface.getGeometry().boundaries(); console.log(bottomSurface);
		for(var e=0; e < edges.length; e++ ){
			var edge = edges[e];
			var srf = new mObj_geom_Surface(  new verb.geom.ExtrudedSurface( edge, extrusionVector ) );
			solid.push(srf);
		}

		return new mObj_geom_Solid( solid );
	};


	/**
	 * Returns a mobiusobject containing a solid (array of surfaces)
	 * @param {array} array_of_surfaces - Mobius Solid Object
	 * @returns {mobiusobject}  - Solid
	 */
	makeSolidBySurfaces = function( array_of_surfaces ){
		return new mObj_geom_Solid( array_of_surfaces );
	};

	//
	// Analysis Functions
	//
	//
	
	/**
	 * Returns a point on the surface at the given parameter values
	 * @param {mobiusobject} surface - mobiusobject with NURBS Surface
	 * @param {int} u - Parameter in u-direction
	 * @param {int} v - Parameter in v-direction
	 * @returns {array} point [x,y,z]
	 */
	getPointOnSurface = function( surface, u, v ){
		var srf = surface.getGeometry();
		if(srf instanceof verb.geom.NurbsSurface)
			return srf.point( u, v );
		else
			return "Invalid Input"
	};

	/**
	 * Returns a point on the curve at the given parameter value
	 * @param {mobiusobject} curve - mobiusobject with NURBS Curve
	 * @param {int} t - Parameter in u-direction
	 * @returns {array} point [x,y,z]
	 */
	getPointOnCurve = function( curve, t ){
		var crv = curve.getGeometry();
		if( crv instanceof verb.geom.NurbsCurve)
			return crv.point( t );
		else
			return "Invalid Input"
	};

	/**
	 * Returns an array of 't' values which divide the curve equally
	 * @param {mobiusobject} curve - mobiusobject with NURBS Curve
	 * @param {int} divisons - Number of divisions in which the curve should be divided
	 * @returns {array} curve parameters [t1, t2, t3 ...]
	 */
	divideCurveByEqualArcLength = function( curve, divisions ){
		var crv = curve;
		if( crv.getGeometry != undefined )
		 	crv = curve.getGeometry();
		var points = crv.divideByEqualArcLength( divisions )
			.map(function(u){ return ( u.u ); } );

		return points;
	};

	/**
	 * Returns an array of 't' values which divide the curve by length
	 * @param {mobiusobject} curve - mobiusobject with NURBS Curve
	 * @param {float} arcLength - Length 
	 * @returns {array} curve parameters [t1, t2, t3 ...]
	 */
	divideCurveByArcLength = function( curve, arcLength ){
		var crv = curve;
		if( crv.getGeometry != undefined )
			crv = curve.getGeometry();
		var points = crv.divideByArcLength( arcLength )
			.map(function(u){ return ( u.u ); } );

		return points; //convert these into vector points
	};

	/**
	 * Returns a tangent on the curve at the given parameter value
	 * @param {mobiusobject} curve - mobiusobject with NURBS Curve
	 * @param {int} t - Parameter in u-direction
	 * @returns {array} tangent [x,y,z]
	 */
	getTangentAtCurveParameter = function( curve, t ){
		var crv = curve;
		if( crv.getGeometry != undefined )
			crv = curve.getGeometry();
		if( crv instanceof verb.geom.NurbsCurve)
			return crv.tangent(t);
		else
			return 'Invalid Input';
	};

	/**
	 * Returns a tangent on the surface at the given parameter values
	 * @param {mobiusobject} surface - mobiusobject with NURBS Surface
	 * @param {int} u - Parameter in u-direction
	 * @param {int} v - Parameter in v-direction
	 * @returns {array} tangent [x,y,z]
	 */
	getNormalAtSurfaceParameter = function( surface, u, v ){
		var srf = surface.getGeometry();
		if(srf instanceof verb.geom.NurbsSurface)
			return srf.normal( u, v);
		else
			return 'Invalid Input';
	};


	/**
	 * Subdivides a surface into smaller surfaces
	 * @param {mobiusobject} surface - mobiusobject with NURBS Surface
	 * @param {int} ugrid - Divisions in u-direction
	 * @param {int} vgrid - Divisions in v-direction
	 * @returns {array} Array of mobiusobjects with NURBS Surfaces
	 */
	makeMeshBySubdivision = function( mObj, ugrid, vgrid ){

		var srf = mObj.getGeometry(); 
		
		if(srf instanceof verb.geom.NurbsSurface){
			var div_surfaces = [], gridPoints = [];
			var uincr = 1/ugrid;
			var vincr = 1/vgrid;

			//for uv lines
			for(var i=0; i <= ugrid; i++){
				for(var seg=0; seg <= vgrid; seg++)
					gridPoints.push(srf.point(i*uincr, seg*vincr)); 
			}

			// creation of polygons from the gridPoints
			for(var i=0; i< gridPoints.length-vgrid-2; i++){
				if((i+vgrid+2)%(vgrid+1) != 0 || i==0){
					// construction of the verbs four point surface
					var mbObj =  new mObj_geom_Surface( new verb.geom.NurbsSurface.byCorners(gridPoints[i], gridPoints[i+1],  gridPoints[i+vgrid+2], gridPoints[i+vgrid+1]) );
					div_surfaces.push(mbObj); 
				}
			}
			return new mObj_geom_Solid( div_surfaces );
		}
		else
			return "Invalid Input"
	};

	/**
	 * Creates a tube of a given radius, from a given line
	 * @param {mobiusobject} line - mobiusobject with NURBS Line
	 * @param {float} radius - Radius of the tube
	 * @returns {mobiusobject} mobiusobject with NURBS Surface
	 */
	makeTubeByLine = function( mObj, radius ){

		var line = mObj.getGeometry();

		var start = line.start();
		var end = line.end();

		var axis = [start[0] - end[0], start[1] - end[1], start[2] - end[2]]
			, height = 1 //this is a multiplying factor to the axis vector
			, radius = radius;

		//construction of a perpendicular vector
		var xaxis = [1, 1, 1];
		if(axis[0] * axis[1] * axis[2] != 0)
			xaxis = [ -axis[1]/axis[0], 1, 0]
		else if(axis.reduce(function(n, val) {
				return n + (val === 0);
			}, 0) > 1)
			xaxis = [0, 0, 0]
		else{
			//is there a better way??
			var flag = 0
			xaxis[axis.indexOf(0)] = 0
			for(var i=0; i < 3; i++){
				if(xaxis[i] == 0)
					continue;
				else if(!flag)
					flag = axis[i]
				else
					xaxis[i] = -(flag/axis[i])
			}
		}

		var tube = new verb.geom.CylindricalSurface( axis, xaxis, end, height, radius );

		return new mObj_geom_Surface( tube );
	};

	/**
	 * Gives the corner points of a surface
	 * @param {mobiusobject} surface - mobiusobject with NURBS Surface
	 * @returns {array} Array of Points [ [corner1], [corner2], [corner3], [corner4] ], where corner is of form - [x, y, z]
	 */
	getCornerPointsFromSurface = function( mObj ){

		var polygon = mObj.getGeometry();

		return [
			polygon.point(0,0),
			polygon.point(1,0),
			polygon.point(1,1),
			polygon.point(0,1)]
	};

	/**
	 * Makes a point from the coordinates
	 * @param {float} x - X Coordinate of the point
	 * @param {float} y - Y Coordinate of the point
	 * @param {float} z - Z Coordinate of the point
	 * @returns {array} Point of form - [x, y, z]
	 */
	makePoint = function(x, y, z){
		return [x, y, z];
	};

	/**
	 * Makes a vertex from a point
	 * @param {array} point - Point in [x, y, z] format
	 * @returns {array} Mobius Vertex Object
	 */
	makeVertex = function( point ){
		return [x, y, z];
	};

	/*
	 *
	 *	Transformation Functions
	 *
	 */

	/**
	 * Creates a unique copy of the object with the same geometry, transformations, material and data at the same location
	 * @param {mobiusobject} mObj - Object to be cloned
	 * @returns {mobiusobject} Cloned object
	 */
	makeCopy = function(mObj){

		/*	if(mObj instanceof Array){
			var newcopy = [];
			for(var obj=0; obj < mObj.length; obj++)
				newcopy.push(VIDAMO.makeCopy(mObj[obj], xCoord, yCoord, zCoord));	
			return newcopy;
		}*/

		// for output cloning
		if( mObj.getGeometry == undefined ){
			console.log("Non-Mobius passed to copy function");
			return mObj;
		}

		// fix: make this into one line code with 'eval'
		var newcopy;
		if(mObj instanceof mObj_geom_Vertex)
			newcopy = new mObj_geom_Vertex( mObj.getGeometry() );
		else if(mObj instanceof mObj_geom_Curve)
			newcopy = new mObj_geom_Curve( mObj.getGeometry() );
		else if(mObj instanceof mObj_geom_Surface)
			newcopy = new mObj_geom_Surface( mObj.getGeometry() );
		else if(mObj instanceof mObj_geom_Solid)
			newcopy = new mObj_geom_Solid( mObj.getGeometry() );

		newcopy.setData( mObj.getData() );
		newcopy.setMaterial( mObj.getMaterial() );

		// if verbs object, has to be copied and translated
/*		if(xCoord != undefined && yCoord != undefined && zCoord != undefined){
			VIDAMO.moveObjectToPoint(newcopy, xCoord, yCoord, zCoord);
		}*/
			

		return newcopy;
		
	};

	/**
	 * Shifts the object relative to its current position
	 * @param {mobiusobject} mObj - Object to be moved
	 * @param {float} shiftX - Distance to be moved in x-direction
	 * @param {float} shiftY - Distance to be moved in y-direction
	 * @param {float} shiftZ - Distance to be moved in z-direction
	 * @returns Null
	 */
	shiftObject = function(mObj, shiftX, shiftY, shiftZ){

		// could be a face too

		// if extractGeometry is called again, the translations would  be lost ..
		// original geometry interactions will not follow the translations - csg is ok, because that derieves from three.js itself
		if (mObj instanceof mObj_geom_Solid)
			mObj = mObj.getGeometry();

		if(mObj instanceof Array){
			for(var obj=0; obj < mObj.length; obj++)
				VIDAMO.shiftObject(mObj[obj], shiftX, shiftY, shiftZ);	
			return;
		}

		var geom = mObj.getGeometry();
		
		var mat = [ [1,0,0, shiftX],
							[0,1,0,shiftY],
								[0,0,1, shiftZ],
									[0,0,0,1]
						];
		var transformedGeometry = geom.transform( mat );
		
		if(geom.center != undefined){ 
			var centre = VIDAMO.getCentre( mObj );
			transformedGeometry.center = function(){ return [ centre[0]+shiftX, centre[1]+shiftY, centre[2]+shiftZ ] }
		}
				
		mObj.setGeometry( transformedGeometry ); 
		
		//return mObj;
	};

	/**
	 * Moves the centre of the object to a target point
	 * @param {mobiusobject} mObj - Object to be moved
	 * @param {float} xCoord - x-coordinate of the target point where the clone appears
	 * @param {float} yCoord - y-coordinate of the target point where the clone appears
	 * @param {float} zCoord - z-coordinate of the target point where the clone appears
	 * @returns Null
	 */
	moveObjectToPoint = function(mObj, xCoord, yCoord, zCoord){

		if (mObj instanceof mObj_geom_Solid)
			mObj = mObj.getGeometry();
		// if extractGeometry is called again, the translations would  be lost ..
		// original geometry interactions will not follow the translations - csg is ok, because that derieves from three.js itself
		if(mObj instanceof Array){
			for(var obj=0; obj < mObj.length; obj++)
				VIDAMO.moveObjectToPoint(mObj[obj], xCoord, yCoord, zCoord);	
			return;
		}
	
		var orCenter = VIDAMO.getCentre(mObj);
			
		// translation required
		var target = [xCoord, yCoord, zCoord];
		var tx = target[0] - orCenter[0];
		var ty = target[1] - orCenter[1];
		var tz = target[2] - orCenter[2]; 
		
		VIDAMO.shiftObject( mObj, tx, ty, tz );		
	};

	/**
	 * Scales the object along different axes
	 * @param {mobiusobject} mObj - Object to be scaled
	 * @param {float} scaleX - Scaling-factor along the x-direction; Should be set to '1' if no scaling is required.
	 * @param {float} scaleY - Scaling-factor along the y-direction; Should be set to '1' if no scaling is required.
	 * @param {float} scaleZ - Scaling-factor along the z-direction; Should be set to '1' if no scaling is required.
	 * @returns Null
	 */
	scaleObject = function(mObj, scaleX, scaleY, scaleZ){

		if (mObj instanceof mObj_geom_Solid)
			mObj = mObj.getGeometry();

		if(mObj instanceof Array){
			for(var obj=0; obj < mObj.length; obj++)
				VIDAMO.scaleObject(mObj[obj], scaleX, scaleY, scaleZ);	
			return;
		}

		// if extractGeometry is called again, the translations would  be lost ..
		// original geometry interactions will not follow the translations - csg is ok, because that derieves from three.js itself
		var geom = mObj.getGeometry();
			
		var mat = [ [scaleX, 0, 0, 0],
							[0,scaleY,0,0],
								[0,0,scaleZ,0],
									[0,0,0,1]
					];
			
		var transformedGeometry = geom.transform(mat);
		mObj.setGeometry( transformedGeometry );
	};

	/**
	 * Rotates the object about different axes
	 * @param {mobiusobject} mObj - Object to be rotated
	 * @param {float} xAxis - Angle (in Radians) about x-axis
	 * @param {float} yAxis - Angle (in Radians) about y-axis
	 * @param {float} zAxis - Angle (in Radians) about z-axis
	 * @returns Null
	 */
	rotateObject = function(mObj, xAxis, yAxis, zAxis){

		if (mObj instanceof mObj_geom_Solid)
			mObj = mObj.getGeometry();

		if(mObj instanceof Array){
			for(var obj=0; obj < mObj.length; obj++)
				VIDAMO.rotateObject(mObj[obj], xAxis, yAxis, zAxis);	
			return;
		}

		var geom = mObj.getGeometry();
		if(geom instanceof verb.geom.NurbsCurve || geom instanceof verb.geom.NurbsSurface){

			var centre = VIDAMO.getCentre(mObj);
			
			var mat_x = [ [1, 0, 0, 0],
							[0,	Math.cos(xAxis), -Math.sin(xAxis),0],
								[0,	Math.sin(xAxis), Math.cos(xAxis),0],
									[0,0,0,1]
						];
						
			var mat_y = [ [Math.cos(yAxis), 0, Math.sin(yAxis), 0],
							[0,1,0,0],
								[-Math.sin(yAxis), 0, Math.cos(yAxis),0],
									[0,0,0,1]
						];
						
			var mat_z = [ [Math.cos(zAxis), -Math.sin(zAxis), 0, 0],
							[Math.sin(zAxis),	Math.cos(zAxis),0,	0],
								[0,	0,	1,	0],
									[0,	0,	0,	1]
						];
			
			var transformedGeometry = geom.transform(mat_x).transform(mat_y).transform(mat_z);

			// if the object is scaled, the object centre remains the same and needs to be redefined
			if(geom.center != undefined)
				transformedGeometry.center = function(){ return VIDAMO.getCentre( mObj ) }

			mObj.setGeometry( transformedGeometry );
		
			// shift to original centre point
			VIDAMO.moveObjectToPoint(mObj, centre[0], centre[1], centre[2]);
		}
	}


	/**
	 * Rotates the object about a  give axis
	 * @param {mobiusobject} mObj - Object to be rotated
	 * @param {array} axis - Axis in [x, y, z] format
	 * @param {radians} angle - Angle (in Radians) about y-axis
	 * @returns Null
	 */
	rotateObjectAboutAxis = function( mObj, axis, angle ){

/*		var end_point = [ axis[0]+point[0], axis[1]+point[1], axis[2]+point[2] ];
		var unit_vector = VIDAMO.getUnitVector( axis );

		var d = Math.sqrt( unit_vector[1]*unit_vector[1] + unit_vector[2]*unit_vector[2] );
		var rx = Math.cosh( unit_vector[2]/d );
		var ry = Math.cosh( d ); 

		var origin = VIDAMO.getCentre(mObj);
		// shift the object to base of the axis
		VIDAMO.moveObjectToPoint( mObj, point[0], point[1], point[2]);


		// rotate the object so y matches up to axis - store this angle
		VIDAMO.rotateObject( mObj, rx, ry, angle );

		// perform transformations

		// rotate opposite to angle previous
		VIDAMO.rotateObject( mObj, 0, -ry, 0 );
		VIDAMO.rotateObject( mObj, -rx, 0, 0 );

		// perform opposite translation
		VIDAMO.moveObjectToPoint( mObj, origin[0], origin[1], origin[2]);*/
		if (mObj instanceof mObj_geom_Solid)
			mObj = mObj.getGeometry();

		if(mObj instanceof Array){
			for(var obj=0; obj < mObj.length; obj++)
				VIDAMO.rotateObjectAboutAxis(mObj[obj], axis, angle );	
			return;
		}

		var geom = mObj.getGeometry();
		if(geom instanceof verb.geom.NurbsCurve || geom instanceof verb.geom.NurbsSurface){

			var centre = VIDAMO.getCentre(mObj);

			var cost = Math.cos( angle );
			var sint = Math.sin( angle );
			var axis = VIDAMO.getUnitVector(axis); 

			var mat = [ [ cost + axis[0]*axis[0]*( 1 - cost ) , axis[0]*axis[1]*( 1 - cost ) - axis[2]*sint, axis[0]*axis[2]*( 1 - cost ) + axis[1]*sint, 0],
							[ axis[0]*axis[1]*( 1 - cost ) + axis[2]*sint,	cost + axis[1]*axis[1]*( 1 - cost ), axis[1]*axis[2]*( 1 - cost ) - axis[0]*sint,0],
								[ axis[2]*axis[0]*( 1 - cost ) - axis[1]*sint,	axis[2]*axis[1]*( 1 - cost ) + axis[0]*sint, cost + axis[2]*axis[2]*( 1 - cost ),0],
									[0,0,0,1]
						];
						
			
			var transformedGeometry = geom.transform( mat );

			// if the object is scaled, the object centre remains the same and needs to be redefined
			if(geom.center != undefined)
				transformedGeometry.center = function(){ return VIDAMO.getCentre( mObj ) } // bug - tranform the centre too - if the object is rotated

			mObj.setGeometry( transformedGeometry );
		
			// shift to original centre point
			//VIDAMO.moveObjectToPoint(mObj, centre[0], centre[1], centre[2]);
		}
	
	};

	/**
	 * Reflects the object about a given plane
	 * @param {mobiusobject} mObj - Object to be reflected
	 * @param {array} planeABC - Parameters A, B, C, D from the plane equation (Ax+By+Cz-D=0) as an array  
	 * @param {radians} angle - Angle (in Radians) about y-axis
	 * @returns Null
	 */
	reflectObjectThroughPlane = function( mObj, planeABC ){

		if (mObj instanceof mObj_geom_Solid)
			mObj = mObj.getGeometry();

		if(mObj instanceof Array){
			for(var obj=0; obj < mObj.length; obj++)
				VIDAMO.rotateObjectAboutAxis(mObj[obj], axis, angle );	
			return;
		}

		var geom = mObj.getGeometry();
		if(geom instanceof verb.geom.NurbsCurve || geom instanceof verb.geom.NurbsSurface){

			var a = planeABC[0]; 
			var b = planeABC[1];
			var c = planeABC[2];
			var d = planeABC[3];

			var mat = [ [ 1-2*a*a, -2*a*b, -2*a*c , 0],
							[ -2*a*b, 1-2*b*b, -2*b*c, 0],
								[ -2*a*c, -2*b*c, 1-2*c*c, 0],
									[0,0,0,1]
						];
						
			
			var transformedGeometry = geom.transform( mat );

			mObj.setGeometry( transformedGeometry );
		
			// shift to original centre point
			//VIDAMO.moveObjectToPoint(mObj, centre[0], centre[1], centre[2]);
		}
	
	};


	/**
	 * Reflects the object about a given plane
	 * @param {mobiusobject} mObj - Object to be reflected
	 * @param {array} planeABC - Parameters A, B, C, D from the plane equation (Ax+By+Cz-D=0) as an array  
	 * @param {radians} angle - Angle (in Radians) about y-axis
	 * @returns Null
	 */
	reflectObjectAboutPlane = function( mObj, pointOnPlane, normalVector ){

		if (mObj instanceof mObj_geom_Solid)
			mObj = mObj.getGeometry();

		if(mObj instanceof Array){
			for(var obj=0; obj < mObj.length; obj++)
				VIDAMO.rotateObjectAboutAxis(mObj[obj], axis, angle );	
			return;
		}

		var geom = mObj.getGeometry();
		if(geom instanceof verb.geom.NurbsCurve || geom instanceof verb.geom.NurbsSurface){

			var a = normalVector[0]; 
			var b = normalVector[1];
			var c = normalVector[2];
			var d = normalVector[0]*pointOnPlane[0] + normalVector[1]*pointOnPlane[1] + normalVector[2]*pointOnPlane[2];

			var mat = [ [ 1-2*a*a, -2*a*b, -2*a*c , 0],
							[ -2*a*b, 1-2*b*b, -2*b*c, 0],
								[ -2*a*c, -2*b*c, 1-2*c*c, 0],
									[0,0,0,1]
						];
						
			
			var transformedGeometry = geom.transform( mat );

			mObj.setGeometry( transformedGeometry );
		
			// shift to original centre point
			//VIDAMO.moveObjectToPoint(mObj, centre[0], centre[1], centre[2]);
		}
	
	};

	/*
	 *	Data Functions
	 *	Input: mobiusobject or Topology Object; Output: Modified Object
	 *
	 */

	/**
	 * Adds material to an object
	 * @param {mobiusobject} obj - Object to which material is to be added
	 * @param {String} material_type - "MeshBasicMaterial", "MeshNormalMaterial", "MeshLambertMaterial", "LineBasicMaterial" etc... 
	 * @param {boolean} wireframe - 'True' if wireframe is required. 
	 * @param {hexCode} color - Hex Code of the color
	 * @param {boolean} transparent - 'True' if transparency is required. 
	 * @returns null
	 */
	addMaterial = function(obj, material_type, wireframe, color_hex, transparent){
		var option = {	
			wireframe: wireframe,
			color: color_hex,
			transparent: transparent,
			side: THREE.DoubleSide
		};
		var material = new THREE[material_type](option);
		
		obj.setMaterial(material);

		return obj;
	};

	/**
	 * Adds data to an object
	 * @param {mobiusobject} obj - Object to which data is to be added
	 * @param {String} dataName - Name of the property
	 * @param {String / int / object ... } dataValue - Value of the property
	 * @returns null
	 */
	addData = function(obj, dataName, dataValue){

		// decide on topology heirarchy also - if edge gets a property, do the vertices also get the same property?
		if(obj.constructor === Array){
			for(var i=0; i<obj.length; i++){
				if(obj[i].getData() == undefined)
					var new_data = {};
					new_data[dataName] = dataValue;
					obj[i].setData( new_data );
			}
		} else{
			if(obj.getData() == undefined)
				var new_data = {};
				new_data[dataName] = dataValue;
				obj.setData( new_data );
		}
	};

